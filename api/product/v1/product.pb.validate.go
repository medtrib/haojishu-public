// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: api/product/v1/product.proto

package v1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on CreateTerminalReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CreateTerminalReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateTerminalReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateTerminalReqMultiError, or nil if none found.
func (m *CreateTerminalReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateTerminalReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 255 {
		err := CreateTerminalReqValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 255 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetKeywords()); l < 1 || l > 255 {
		err := CreateTerminalReqValidationError{
			field:  "Keywords",
			reason: "value length must be between 1 and 255 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetDescription()); l < 1 || l > 255 {
		err := CreateTerminalReqValidationError{
			field:  "Description",
			reason: "value length must be between 1 and 255 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetImg()); l < 1 || l > 255 {
		err := CreateTerminalReqValidationError{
			field:  "Img",
			reason: "value length must be between 1 and 255 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetSort() <= 0 {
		err := CreateTerminalReqValidationError{
			field:  "Sort",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return CreateTerminalReqMultiError(errors)
	}

	return nil
}

// CreateTerminalReqMultiError is an error wrapping multiple validation errors
// returned by CreateTerminalReq.ValidateAll() if the designated constraints
// aren't met.
type CreateTerminalReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateTerminalReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateTerminalReqMultiError) AllErrors() []error { return m }

// CreateTerminalReqValidationError is the validation error returned by
// CreateTerminalReq.Validate if the designated constraints aren't met.
type CreateTerminalReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateTerminalReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateTerminalReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateTerminalReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateTerminalReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateTerminalReqValidationError) ErrorName() string {
	return "CreateTerminalReqValidationError"
}

// Error satisfies the builtin error interface
func (e CreateTerminalReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateTerminalReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateTerminalReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateTerminalReqValidationError{}

// Validate checks the field values on Terminal with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Terminal) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Terminal with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TerminalMultiError, or nil
// if none found.
func (m *Terminal) ValidateAll() error {
	return m.validate(true)
}

func (m *Terminal) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 255 {
		err := TerminalValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 255 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetKeywords()); l < 1 || l > 255 {
		err := TerminalValidationError{
			field:  "Keywords",
			reason: "value length must be between 1 and 255 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetDescription()); l < 1 || l > 255 {
		err := TerminalValidationError{
			field:  "Description",
			reason: "value length must be between 1 and 255 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetImg()); l < 1 || l > 255 {
		err := TerminalValidationError{
			field:  "Img",
			reason: "value length must be between 1 and 255 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetSort() <= 0 {
		err := TerminalValidationError{
			field:  "Sort",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return TerminalMultiError(errors)
	}

	return nil
}

// TerminalMultiError is an error wrapping multiple validation errors returned
// by Terminal.ValidateAll() if the designated constraints aren't met.
type TerminalMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TerminalMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TerminalMultiError) AllErrors() []error { return m }

// TerminalValidationError is the validation error returned by
// Terminal.Validate if the designated constraints aren't met.
type TerminalValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TerminalValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TerminalValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TerminalValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TerminalValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TerminalValidationError) ErrorName() string { return "TerminalValidationError" }

// Error satisfies the builtin error interface
func (e TerminalValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTerminal.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TerminalValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TerminalValidationError{}

// Validate checks the field values on EditTerminalReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *EditTerminalReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EditTerminalReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// EditTerminalReqMultiError, or nil if none found.
func (m *EditTerminalReq) ValidateAll() error {
	return m.validate(true)
}

func (m *EditTerminalReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := EditTerminalReqValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 255 {
		err := EditTerminalReqValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 255 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetKeywords()); l < 1 || l > 255 {
		err := EditTerminalReqValidationError{
			field:  "Keywords",
			reason: "value length must be between 1 and 255 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetDescription()); l < 1 || l > 255 {
		err := EditTerminalReqValidationError{
			field:  "Description",
			reason: "value length must be between 1 and 255 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetImg()); l < 1 || l > 255 {
		err := EditTerminalReqValidationError{
			field:  "Img",
			reason: "value length must be between 1 and 255 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetSort() <= 0 {
		err := EditTerminalReqValidationError{
			field:  "Sort",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return EditTerminalReqMultiError(errors)
	}

	return nil
}

// EditTerminalReqMultiError is an error wrapping multiple validation errors
// returned by EditTerminalReq.ValidateAll() if the designated constraints
// aren't met.
type EditTerminalReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EditTerminalReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EditTerminalReqMultiError) AllErrors() []error { return m }

// EditTerminalReqValidationError is the validation error returned by
// EditTerminalReq.Validate if the designated constraints aren't met.
type EditTerminalReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EditTerminalReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EditTerminalReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EditTerminalReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EditTerminalReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EditTerminalReqValidationError) ErrorName() string { return "EditTerminalReqValidationError" }

// Error satisfies the builtin error interface
func (e EditTerminalReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEditTerminalReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EditTerminalReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EditTerminalReqValidationError{}

// Validate checks the field values on DelIdReq with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DelIdReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DelIdReq with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DelIdReqMultiError, or nil
// if none found.
func (m *DelIdReq) ValidateAll() error {
	return m.validate(true)
}

func (m *DelIdReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := DelIdReqValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DelIdReqMultiError(errors)
	}

	return nil
}

// DelIdReqMultiError is an error wrapping multiple validation errors returned
// by DelIdReq.ValidateAll() if the designated constraints aren't met.
type DelIdReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DelIdReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DelIdReqMultiError) AllErrors() []error { return m }

// DelIdReqValidationError is the validation error returned by
// DelIdReq.Validate if the designated constraints aren't met.
type DelIdReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DelIdReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DelIdReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DelIdReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DelIdReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DelIdReqValidationError) ErrorName() string { return "DelIdReqValidationError" }

// Error satisfies the builtin error interface
func (e DelIdReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDelIdReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DelIdReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DelIdReqValidationError{}

// Validate checks the field values on ListTerminalRep with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListTerminalRep) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListTerminalRep with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListTerminalRepMultiError, or nil if none found.
func (m *ListTerminalRep) ValidateAll() error {
	return m.validate(true)
}

func (m *ListTerminalRep) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListTerminalRepValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListTerminalRepValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListTerminalRepValidationError{
					field:  fmt.Sprintf("List[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListTerminalRepMultiError(errors)
	}

	return nil
}

// ListTerminalRepMultiError is an error wrapping multiple validation errors
// returned by ListTerminalRep.ValidateAll() if the designated constraints
// aren't met.
type ListTerminalRepMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListTerminalRepMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListTerminalRepMultiError) AllErrors() []error { return m }

// ListTerminalRepValidationError is the validation error returned by
// ListTerminalRep.Validate if the designated constraints aren't met.
type ListTerminalRepValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListTerminalRepValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListTerminalRepValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListTerminalRepValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListTerminalRepValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListTerminalRepValidationError) ErrorName() string { return "ListTerminalRepValidationError" }

// Error satisfies the builtin error interface
func (e ListTerminalRepValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListTerminalRep.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListTerminalRepValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListTerminalRepValidationError{}

// Validate checks the field values on PageListTerminalReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PageListTerminalReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PageListTerminalReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PageListTerminalReqMultiError, or nil if none found.
func (m *PageListTerminalReq) ValidateAll() error {
	return m.validate(true)
}

func (m *PageListTerminalReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetPage() <= 0 {
		err := PageListTerminalReqValidationError{
			field:  "Page",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetPageSize() <= 0 {
		err := PageListTerminalReqValidationError{
			field:  "PageSize",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Name

	if len(errors) > 0 {
		return PageListTerminalReqMultiError(errors)
	}

	return nil
}

// PageListTerminalReqMultiError is an error wrapping multiple validation
// errors returned by PageListTerminalReq.ValidateAll() if the designated
// constraints aren't met.
type PageListTerminalReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PageListTerminalReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PageListTerminalReqMultiError) AllErrors() []error { return m }

// PageListTerminalReqValidationError is the validation error returned by
// PageListTerminalReq.Validate if the designated constraints aren't met.
type PageListTerminalReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PageListTerminalReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PageListTerminalReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PageListTerminalReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PageListTerminalReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PageListTerminalReqValidationError) ErrorName() string {
	return "PageListTerminalReqValidationError"
}

// Error satisfies the builtin error interface
func (e PageListTerminalReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPageListTerminalReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PageListTerminalReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PageListTerminalReqValidationError{}

// Validate checks the field values on PageListTerminalRep with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PageListTerminalRep) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PageListTerminalRep with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PageListTerminalRepMultiError, or nil if none found.
func (m *PageListTerminalRep) ValidateAll() error {
	return m.validate(true)
}

func (m *PageListTerminalRep) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Total

	for idx, item := range m.GetList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PageListTerminalRepValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PageListTerminalRepValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PageListTerminalRepValidationError{
					field:  fmt.Sprintf("List[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return PageListTerminalRepMultiError(errors)
	}

	return nil
}

// PageListTerminalRepMultiError is an error wrapping multiple validation
// errors returned by PageListTerminalRep.ValidateAll() if the designated
// constraints aren't met.
type PageListTerminalRepMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PageListTerminalRepMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PageListTerminalRepMultiError) AllErrors() []error { return m }

// PageListTerminalRepValidationError is the validation error returned by
// PageListTerminalRep.Validate if the designated constraints aren't met.
type PageListTerminalRepValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PageListTerminalRepValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PageListTerminalRepValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PageListTerminalRepValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PageListTerminalRepValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PageListTerminalRepValidationError) ErrorName() string {
	return "PageListTerminalRepValidationError"
}

// Error satisfies the builtin error interface
func (e PageListTerminalRepValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPageListTerminalRep.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PageListTerminalRepValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PageListTerminalRepValidationError{}

// Validate checks the field values on ProductStatus with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ProductStatus) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProductStatus with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ProductStatusMultiError, or
// nil if none found.
func (m *ProductStatus) ValidateAll() error {
	return m.validate(true)
}

func (m *ProductStatus) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Success

	if len(errors) > 0 {
		return ProductStatusMultiError(errors)
	}

	return nil
}

// ProductStatusMultiError is an error wrapping multiple validation errors
// returned by ProductStatus.ValidateAll() if the designated constraints
// aren't met.
type ProductStatusMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProductStatusMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProductStatusMultiError) AllErrors() []error { return m }

// ProductStatusValidationError is the validation error returned by
// ProductStatus.Validate if the designated constraints aren't met.
type ProductStatusValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProductStatusValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProductStatusValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProductStatusValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProductStatusValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProductStatusValidationError) ErrorName() string { return "ProductStatusValidationError" }

// Error satisfies the builtin error interface
func (e ProductStatusValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProductStatus.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProductStatusValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProductStatusValidationError{}

// Validate checks the field values on CreateKindReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CreateKindReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateKindReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CreateKindReqMultiError, or
// nil if none found.
func (m *CreateKindReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateKindReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 255 {
		err := CreateKindReqValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 255 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return CreateKindReqMultiError(errors)
	}

	return nil
}

// CreateKindReqMultiError is an error wrapping multiple validation errors
// returned by CreateKindReq.ValidateAll() if the designated constraints
// aren't met.
type CreateKindReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateKindReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateKindReqMultiError) AllErrors() []error { return m }

// CreateKindReqValidationError is the validation error returned by
// CreateKindReq.Validate if the designated constraints aren't met.
type CreateKindReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateKindReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateKindReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateKindReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateKindReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateKindReqValidationError) ErrorName() string { return "CreateKindReqValidationError" }

// Error satisfies the builtin error interface
func (e CreateKindReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateKindReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateKindReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateKindReqValidationError{}

// Validate checks the field values on EditKindReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *EditKindReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EditKindReq with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in EditKindReqMultiError, or
// nil if none found.
func (m *EditKindReq) ValidateAll() error {
	return m.validate(true)
}

func (m *EditKindReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 255 {
		err := EditKindReqValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 255 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return EditKindReqMultiError(errors)
	}

	return nil
}

// EditKindReqMultiError is an error wrapping multiple validation errors
// returned by EditKindReq.ValidateAll() if the designated constraints aren't met.
type EditKindReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EditKindReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EditKindReqMultiError) AllErrors() []error { return m }

// EditKindReqValidationError is the validation error returned by
// EditKindReq.Validate if the designated constraints aren't met.
type EditKindReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EditKindReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EditKindReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EditKindReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EditKindReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EditKindReqValidationError) ErrorName() string { return "EditKindReqValidationError" }

// Error satisfies the builtin error interface
func (e EditKindReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEditKindReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EditKindReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EditKindReqValidationError{}

// Validate checks the field values on Kind with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Kind) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Kind with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in KindMultiError, or nil if none found.
func (m *Kind) ValidateAll() error {
	return m.validate(true)
}

func (m *Kind) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 255 {
		err := KindValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 255 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return KindMultiError(errors)
	}

	return nil
}

// KindMultiError is an error wrapping multiple validation errors returned by
// Kind.ValidateAll() if the designated constraints aren't met.
type KindMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m KindMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m KindMultiError) AllErrors() []error { return m }

// KindValidationError is the validation error returned by Kind.Validate if the
// designated constraints aren't met.
type KindValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e KindValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e KindValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e KindValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e KindValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e KindValidationError) ErrorName() string { return "KindValidationError" }

// Error satisfies the builtin error interface
func (e KindValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sKind.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = KindValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = KindValidationError{}

// Validate checks the field values on ListKindRep with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ListKindRep) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListKindRep with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ListKindRepMultiError, or
// nil if none found.
func (m *ListKindRep) ValidateAll() error {
	return m.validate(true)
}

func (m *ListKindRep) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListKindRepValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListKindRepValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListKindRepValidationError{
					field:  fmt.Sprintf("List[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListKindRepMultiError(errors)
	}

	return nil
}

// ListKindRepMultiError is an error wrapping multiple validation errors
// returned by ListKindRep.ValidateAll() if the designated constraints aren't met.
type ListKindRepMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListKindRepMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListKindRepMultiError) AllErrors() []error { return m }

// ListKindRepValidationError is the validation error returned by
// ListKindRep.Validate if the designated constraints aren't met.
type ListKindRepValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListKindRepValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListKindRepValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListKindRepValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListKindRepValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListKindRepValidationError) ErrorName() string { return "ListKindRepValidationError" }

// Error satisfies the builtin error interface
func (e ListKindRepValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListKindRep.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListKindRepValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListKindRepValidationError{}

// Validate checks the field values on PageListKindReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *PageListKindReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PageListKindReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PageListKindReqMultiError, or nil if none found.
func (m *PageListKindReq) ValidateAll() error {
	return m.validate(true)
}

func (m *PageListKindReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetPage() <= 0 {
		err := PageListKindReqValidationError{
			field:  "Page",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetPageSize() <= 0 {
		err := PageListKindReqValidationError{
			field:  "PageSize",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 255 {
		err := PageListKindReqValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 255 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return PageListKindReqMultiError(errors)
	}

	return nil
}

// PageListKindReqMultiError is an error wrapping multiple validation errors
// returned by PageListKindReq.ValidateAll() if the designated constraints
// aren't met.
type PageListKindReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PageListKindReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PageListKindReqMultiError) AllErrors() []error { return m }

// PageListKindReqValidationError is the validation error returned by
// PageListKindReq.Validate if the designated constraints aren't met.
type PageListKindReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PageListKindReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PageListKindReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PageListKindReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PageListKindReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PageListKindReqValidationError) ErrorName() string { return "PageListKindReqValidationError" }

// Error satisfies the builtin error interface
func (e PageListKindReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPageListKindReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PageListKindReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PageListKindReqValidationError{}

// Validate checks the field values on PageListKindRep with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *PageListKindRep) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PageListKindRep with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PageListKindRepMultiError, or nil if none found.
func (m *PageListKindRep) ValidateAll() error {
	return m.validate(true)
}

func (m *PageListKindRep) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetTotal() <= 0 {
		err := PageListKindRepValidationError{
			field:  "Total",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PageListKindRepValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PageListKindRepValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PageListKindRepValidationError{
					field:  fmt.Sprintf("List[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return PageListKindRepMultiError(errors)
	}

	return nil
}

// PageListKindRepMultiError is an error wrapping multiple validation errors
// returned by PageListKindRep.ValidateAll() if the designated constraints
// aren't met.
type PageListKindRepMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PageListKindRepMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PageListKindRepMultiError) AllErrors() []error { return m }

// PageListKindRepValidationError is the validation error returned by
// PageListKindRep.Validate if the designated constraints aren't met.
type PageListKindRepValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PageListKindRepValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PageListKindRepValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PageListKindRepValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PageListKindRepValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PageListKindRepValidationError) ErrorName() string { return "PageListKindRepValidationError" }

// Error satisfies the builtin error interface
func (e PageListKindRepValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPageListKindRep.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PageListKindRepValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PageListKindRepValidationError{}

// Validate checks the field values on CreateProductReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CreateProductReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateProductReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateProductReqMultiError, or nil if none found.
func (m *CreateProductReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateProductReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetKindId() <= 0 {
		err := CreateProductReqValidationError{
			field:  "KindId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 255 {
		err := CreateProductReqValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 255 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetKeyword()); l < 1 || l > 255 {
		err := CreateProductReqValidationError{
			field:  "Keyword",
			reason: "value length must be between 1 and 255 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetDescription()); l < 1 || l > 255 {
		err := CreateProductReqValidationError{
			field:  "Description",
			reason: "value length must be between 1 and 255 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return CreateProductReqMultiError(errors)
	}

	return nil
}

// CreateProductReqMultiError is an error wrapping multiple validation errors
// returned by CreateProductReq.ValidateAll() if the designated constraints
// aren't met.
type CreateProductReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateProductReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateProductReqMultiError) AllErrors() []error { return m }

// CreateProductReqValidationError is the validation error returned by
// CreateProductReq.Validate if the designated constraints aren't met.
type CreateProductReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateProductReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateProductReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateProductReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateProductReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateProductReqValidationError) ErrorName() string { return "CreateProductReqValidationError" }

// Error satisfies the builtin error interface
func (e CreateProductReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateProductReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateProductReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateProductReqValidationError{}

// Validate checks the field values on EditProductReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *EditProductReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EditProductReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in EditProductReqMultiError,
// or nil if none found.
func (m *EditProductReq) ValidateAll() error {
	return m.validate(true)
}

func (m *EditProductReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := EditProductReqValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetKindId() <= 0 {
		err := EditProductReqValidationError{
			field:  "KindId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 255 {
		err := EditProductReqValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 255 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetKeywords()); l < 1 || l > 255 {
		err := EditProductReqValidationError{
			field:  "Keywords",
			reason: "value length must be between 1 and 255 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetDescription()); l < 1 || l > 255 {
		err := EditProductReqValidationError{
			field:  "Description",
			reason: "value length must be between 1 and 255 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return EditProductReqMultiError(errors)
	}

	return nil
}

// EditProductReqMultiError is an error wrapping multiple validation errors
// returned by EditProductReq.ValidateAll() if the designated constraints
// aren't met.
type EditProductReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EditProductReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EditProductReqMultiError) AllErrors() []error { return m }

// EditProductReqValidationError is the validation error returned by
// EditProductReq.Validate if the designated constraints aren't met.
type EditProductReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EditProductReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EditProductReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EditProductReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EditProductReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EditProductReqValidationError) ErrorName() string { return "EditProductReqValidationError" }

// Error satisfies the builtin error interface
func (e EditProductReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEditProductReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EditProductReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EditProductReqValidationError{}

// Validate checks the field values on ProductInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ProductInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProductInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ProductInfoMultiError, or
// nil if none found.
func (m *ProductInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *ProductInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := ProductInfoValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetKindId() <= 0 {
		err := ProductInfoValidationError{
			field:  "KindId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 255 {
		err := ProductInfoValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 255 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetKeywords()); l < 1 || l > 255 {
		err := ProductInfoValidationError{
			field:  "Keywords",
			reason: "value length must be between 1 and 255 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetDescription()); l < 1 || l > 255 {
		err := ProductInfoValidationError{
			field:  "Description",
			reason: "value length must be between 1 and 255 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for CreatedAt

	// no validation rules for UpdatedAt

	// no validation rules for DeletedAt

	if len(errors) > 0 {
		return ProductInfoMultiError(errors)
	}

	return nil
}

// ProductInfoMultiError is an error wrapping multiple validation errors
// returned by ProductInfo.ValidateAll() if the designated constraints aren't met.
type ProductInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProductInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProductInfoMultiError) AllErrors() []error { return m }

// ProductInfoValidationError is the validation error returned by
// ProductInfo.Validate if the designated constraints aren't met.
type ProductInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProductInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProductInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProductInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProductInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProductInfoValidationError) ErrorName() string { return "ProductInfoValidationError" }

// Error satisfies the builtin error interface
func (e ProductInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProductInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProductInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProductInfoValidationError{}

// Validate checks the field values on ListProductRep with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ListProductRep) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListProductRep with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ListProductRepMultiError,
// or nil if none found.
func (m *ListProductRep) ValidateAll() error {
	return m.validate(true)
}

func (m *ListProductRep) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListProductRepValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListProductRepValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListProductRepValidationError{
					field:  fmt.Sprintf("List[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListProductRepMultiError(errors)
	}

	return nil
}

// ListProductRepMultiError is an error wrapping multiple validation errors
// returned by ListProductRep.ValidateAll() if the designated constraints
// aren't met.
type ListProductRepMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListProductRepMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListProductRepMultiError) AllErrors() []error { return m }

// ListProductRepValidationError is the validation error returned by
// ListProductRep.Validate if the designated constraints aren't met.
type ListProductRepValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListProductRepValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListProductRepValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListProductRepValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListProductRepValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListProductRepValidationError) ErrorName() string { return "ListProductRepValidationError" }

// Error satisfies the builtin error interface
func (e ListProductRepValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListProductRep.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListProductRepValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListProductRepValidationError{}
